{"ast":null,"code":"'use strict';\n/**\r\n * @module symbol-tree\r\n * @author Joris van der Wel <joris@jorisvanderwel.com>\r\n */\n\nconst SymbolTreeNode = require('./SymbolTreeNode');\n\nconst TreePosition = require('./TreePosition');\n\nconst TreeIterator = require('./TreeIterator');\n\nfunction returnTrue() {\n  return true;\n}\n\nfunction reverseArrayIndex(array, reverseIndex) {\n  return array[array.length - 1 - reverseIndex]; // no need to check `index >= 0`\n}\n\nclass SymbolTree {\n  /**\r\n   * @constructor\r\n   * @alias module:symbol-tree\r\n   * @param {string} [description='SymbolTree data'] Description used for the Symbol\r\n   */\n  constructor(description) {\n    this.symbol = Symbol(description || 'SymbolTree data');\n  }\n  /**\r\n   * You can use this function to (optionally) initialize an object right after its creation,\r\n   * to take advantage of V8's fast properties. Also useful if you would like to\r\n   * freeze your object.\r\n   *\r\n   * `O(1)`\r\n   *\r\n   * @method\r\n   * @alias module:symbol-tree#initialize\r\n   * @param {Object} object\r\n   * @return {Object} object\r\n   */\n\n\n  initialize(object) {\n    this._node(object);\n\n    return object;\n  }\n\n  _node(object) {\n    if (!object) {\n      return null;\n    }\n\n    const node = object[this.symbol];\n\n    if (node) {\n      return node;\n    }\n\n    return object[this.symbol] = new SymbolTreeNode();\n  }\n  /**\r\n   * Returns `true` if the object has any children. Otherwise it returns `false`.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method hasChildren\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Boolean}\r\n   */\n\n\n  hasChildren(object) {\n    return this._node(object).hasChildren;\n  }\n  /**\r\n   * Returns the first child of the given object.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method firstChild\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object}\r\n   */\n\n\n  firstChild(object) {\n    return this._node(object).firstChild;\n  }\n  /**\r\n   * Returns the last child of the given object.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method lastChild\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object}\r\n   */\n\n\n  lastChild(object) {\n    return this._node(object).lastChild;\n  }\n  /**\r\n   * Returns the previous sibling of the given object.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method previousSibling\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object}\r\n   */\n\n\n  previousSibling(object) {\n    return this._node(object).previousSibling;\n  }\n  /**\r\n   * Returns the next sibling of the given object.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method nextSibling\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object}\r\n   */\n\n\n  nextSibling(object) {\n    return this._node(object).nextSibling;\n  }\n  /**\r\n   * Return the parent of the given object.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method parent\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object}\r\n   */\n\n\n  parent(object) {\n    return this._node(object).parent;\n  }\n  /**\r\n   * Find the inclusive descendant that is last in tree order of the given object.\r\n   *\r\n   * * `O(n)` (worst case) where `n` is the depth of the subtree of `object`\r\n   *\r\n   * @method lastInclusiveDescendant\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object}\r\n   */\n\n\n  lastInclusiveDescendant(object) {\n    let lastChild;\n    let current = object;\n\n    while (lastChild = this._node(current).lastChild) {\n      current = lastChild;\n    }\n\n    return current;\n  }\n  /**\r\n   * Find the preceding object (A) of the given object (B).\r\n   * An object A is preceding an object B if A and B are in the same tree\r\n   * and A comes before B in tree order.\r\n   *\r\n   * * `O(n)` (worst case)\r\n   * * `O(1)` (amortized when walking the entire tree)\r\n   *\r\n   * @method preceding\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @param {Object} [options]\r\n   * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\r\n   *        of the return value (or else null is returned). This check _assumes_\r\n   *        that `root` is also an inclusive ancestor of the given `object`\r\n   * @return {?Object}\r\n   */\n\n\n  preceding(object, options) {\n    const treeRoot = options && options.root;\n\n    if (object === treeRoot) {\n      return null;\n    }\n\n    const previousSibling = this._node(object).previousSibling;\n\n    if (previousSibling) {\n      return this.lastInclusiveDescendant(previousSibling);\n    } // if there is no previous sibling return the parent (might be null)\n\n\n    return this._node(object).parent;\n  }\n  /**\r\n   * Find the following object (A) of the given object (B).\r\n   * An object A is following an object B if A and B are in the same tree\r\n   * and A comes after B in tree order.\r\n   *\r\n   * * `O(n)` (worst case) where `n` is the amount of objects in the entire tree\r\n   * * `O(1)` (amortized when walking the entire tree)\r\n   *\r\n   * @method following\r\n   * @memberOf module:symbol-tree#\r\n   * @param {!Object} object\r\n   * @param {Object} [options]\r\n   * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\r\n   *        of the return value (or else null is returned). This check _assumes_\r\n   *        that `root` is also an inclusive ancestor of the given `object`\r\n   * @param {Boolean} [options.skipChildren=false] If set, ignore the children of `object`\r\n   * @return {?Object}\r\n   */\n\n\n  following(object, options) {\n    const treeRoot = options && options.root;\n    const skipChildren = options && options.skipChildren;\n\n    const firstChild = !skipChildren && this._node(object).firstChild;\n\n    if (firstChild) {\n      return firstChild;\n    }\n\n    let current = object;\n\n    do {\n      if (current === treeRoot) {\n        return null;\n      }\n\n      const nextSibling = this._node(current).nextSibling;\n\n      if (nextSibling) {\n        return nextSibling;\n      }\n\n      current = this._node(current).parent;\n    } while (current);\n\n    return null;\n  }\n  /**\r\n   * Append all children of the given object to an array.\r\n   *\r\n   * * `O(n)` where `n` is the amount of children of the given `parent`\r\n   *\r\n   * @method childrenToArray\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} parent\r\n   * @param {Object} [options]\r\n   * @param {Object[]} [options.array=[]]\r\n   * @param {Function} [options.filter] Function to test each object before it is added to the array.\r\n   *                            Invoked with arguments (object). Should return `true` if an object\r\n   *                            is to be included.\r\n   * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\r\n   * @return {Object[]}\r\n   */\n\n\n  childrenToArray(parent, options) {\n    const array = options && options.array || [];\n    const filter = options && options.filter || returnTrue;\n    const thisArg = options && options.thisArg || undefined;\n\n    const parentNode = this._node(parent);\n\n    let object = parentNode.firstChild;\n    let index = 0;\n\n    while (object) {\n      const node = this._node(object);\n\n      node.setCachedIndex(parentNode, index);\n\n      if (filter.call(thisArg, object)) {\n        array.push(object);\n      }\n\n      object = node.nextSibling;\n      ++index;\n    }\n\n    return array;\n  }\n  /**\r\n   * Append all inclusive ancestors of the given object to an array.\r\n   *\r\n   * * `O(n)` where `n` is the amount of ancestors of the given `object`\r\n   *\r\n   * @method ancestorsToArray\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @param {Object} [options]\r\n   * @param {Object[]} [options.array=[]]\r\n   * @param {Function} [options.filter] Function to test each object before it is added to the array.\r\n   *                            Invoked with arguments (object). Should return `true` if an object\r\n   *                            is to be included.\r\n   * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\r\n   * @return {Object[]}\r\n   */\n\n\n  ancestorsToArray(object, options) {\n    const array = options && options.array || [];\n    const filter = options && options.filter || returnTrue;\n    const thisArg = options && options.thisArg || undefined;\n    let ancestor = object;\n\n    while (ancestor) {\n      if (filter.call(thisArg, ancestor)) {\n        array.push(ancestor);\n      }\n\n      ancestor = this._node(ancestor).parent;\n    }\n\n    return array;\n  }\n  /**\r\n   * Append all descendants of the given object to an array (in tree order).\r\n   *\r\n   * * `O(n)` where `n` is the amount of objects in the sub-tree of the given `object`\r\n   *\r\n   * @method treeToArray\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} root\r\n   * @param {Object} [options]\r\n   * @param {Object[]} [options.array=[]]\r\n   * @param {Function} [options.filter] Function to test each object before it is added to the array.\r\n   *                            Invoked with arguments (object). Should return `true` if an object\r\n   *                            is to be included.\r\n   * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\r\n   * @return {Object[]}\r\n   */\n\n\n  treeToArray(root, options) {\n    const array = options && options.array || [];\n    const filter = options && options.filter || returnTrue;\n    const thisArg = options && options.thisArg || undefined;\n    let object = root;\n\n    while (object) {\n      if (filter.call(thisArg, object)) {\n        array.push(object);\n      }\n\n      object = this.following(object, {\n        root: root\n      });\n    }\n\n    return array;\n  }\n  /**\r\n   * Iterate over all children of the given object\r\n   *\r\n   * * `O(1)` for a single iteration\r\n   *\r\n   * @method childrenIterator\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} parent\r\n   * @param {Object} [options]\r\n   * @param {Boolean} [options.reverse=false]\r\n   * @return {Object} An iterable iterator (ES6)\r\n   */\n\n\n  childrenIterator(parent, options) {\n    const reverse = options && options.reverse;\n\n    const parentNode = this._node(parent);\n\n    return new TreeIterator(this, parent, reverse ? parentNode.lastChild : parentNode.firstChild, reverse ? TreeIterator.PREV : TreeIterator.NEXT);\n  }\n  /**\r\n   * Iterate over all the previous siblings of the given object. (in reverse tree order)\r\n   *\r\n   * * `O(1)` for a single iteration\r\n   *\r\n   * @method previousSiblingsIterator\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object} An iterable iterator (ES6)\r\n   */\n\n\n  previousSiblingsIterator(object) {\n    return new TreeIterator(this, object, this._node(object).previousSibling, TreeIterator.PREV);\n  }\n  /**\r\n   * Iterate over all the next siblings of the given object. (in tree order)\r\n   *\r\n   * * `O(1)` for a single iteration\r\n   *\r\n   * @method nextSiblingsIterator\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object} An iterable iterator (ES6)\r\n   */\n\n\n  nextSiblingsIterator(object) {\n    return new TreeIterator(this, object, this._node(object).nextSibling, TreeIterator.NEXT);\n  }\n  /**\r\n   * Iterate over all inclusive ancestors of the given object\r\n   *\r\n   * * `O(1)` for a single iteration\r\n   *\r\n   * @method ancestorsIterator\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object} An iterable iterator (ES6)\r\n   */\n\n\n  ancestorsIterator(object) {\n    return new TreeIterator(this, object, object, TreeIterator.PARENT);\n  }\n  /**\r\n   * Iterate over all descendants of the given object (in tree order).\r\n   *\r\n   * Where `n` is the amount of objects in the sub-tree of the given `root`:\r\n   *\r\n   * * `O(n)` (worst case for a single iteration)\r\n   * * `O(n)` (amortized, when completing the iterator)\r\n   *\r\n   * @method treeIterator\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} root\r\n   * @param {Object} options\r\n   * @param {Boolean} [options.reverse=false]\r\n   * @return {Object} An iterable iterator (ES6)\r\n   */\n\n\n  treeIterator(root, options) {\n    const reverse = options && options.reverse;\n    return new TreeIterator(this, root, reverse ? this.lastInclusiveDescendant(root) : root, reverse ? TreeIterator.PRECEDING : TreeIterator.FOLLOWING);\n  }\n  /**\r\n   * Find the index of the given object (the number of preceding siblings).\r\n   *\r\n   * * `O(n)` where `n` is the amount of preceding siblings\r\n   * * `O(1)` (amortized, if the tree is not modified)\r\n   *\r\n   * @method index\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} child\r\n   * @return {Number} The number of preceding siblings, or -1 if the object has no parent\r\n   */\n\n\n  index(child) {\n    const childNode = this._node(child);\n\n    const parentNode = this._node(childNode.parent);\n\n    if (!parentNode) {\n      // In principal, you could also find out the number of preceding siblings\n      // for objects that do not have a parent. This method limits itself only to\n      // objects that have a parent because that lets us optimize more.\n      return -1;\n    }\n\n    let currentIndex = childNode.getCachedIndex(parentNode);\n\n    if (currentIndex >= 0) {\n      return currentIndex;\n    }\n\n    currentIndex = 0;\n    let object = parentNode.firstChild;\n\n    if (parentNode.childIndexCachedUpTo) {\n      const cachedUpToNode = this._node(parentNode.childIndexCachedUpTo);\n\n      object = cachedUpToNode.nextSibling;\n      currentIndex = cachedUpToNode.getCachedIndex(parentNode) + 1;\n    }\n\n    while (object) {\n      const node = this._node(object);\n\n      node.setCachedIndex(parentNode, currentIndex);\n\n      if (object === child) {\n        break;\n      }\n\n      ++currentIndex;\n      object = node.nextSibling;\n    }\n\n    parentNode.childIndexCachedUpTo = child;\n    return currentIndex;\n  }\n  /**\r\n   * Calculate the number of children.\r\n   *\r\n   * * `O(n)` where `n` is the amount of children\r\n   * * `O(1)` (amortized, if the tree is not modified)\r\n   *\r\n   * @method childrenCount\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} parent\r\n   * @return {Number}\r\n   */\n\n\n  childrenCount(parent) {\n    const parentNode = this._node(parent);\n\n    if (!parentNode.lastChild) {\n      return 0;\n    }\n\n    return this.index(parentNode.lastChild) + 1;\n  }\n  /**\r\n   * Compare the position of an object relative to another object. A bit set is returned:\r\n   *\r\n   * <ul>\r\n   *     <li>DISCONNECTED : 1</li>\r\n   *     <li>PRECEDING : 2</li>\r\n   *     <li>FOLLOWING : 4</li>\r\n   *     <li>CONTAINS : 8</li>\r\n   *     <li>CONTAINED_BY : 16</li>\r\n   * </ul>\r\n   *\r\n   * The semantics are the same as compareDocumentPosition in DOM, with the exception that\r\n   * DISCONNECTED never occurs with any other bit.\r\n   *\r\n   * where `n` and `m` are the amount of ancestors of `left` and `right`;\r\n   * where `o` is the amount of children of the lowest common ancestor of `left` and `right`:\r\n   *\r\n   * * `O(n + m + o)` (worst case)\r\n   * * `O(n + m)` (amortized, if the tree is not modified)\r\n   *\r\n   * @method compareTreePosition\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} left\r\n   * @param {Object} right\r\n   * @return {Number}\r\n   */\n\n\n  compareTreePosition(left, right) {\n    // In DOM terms:\n    // left = reference / context object\n    // right = other\n    if (left === right) {\n      return 0;\n    }\n    /* jshint -W016 */\n\n\n    const leftAncestors = [];\n    {\n      // inclusive\n      let leftAncestor = left;\n\n      while (leftAncestor) {\n        if (leftAncestor === right) {\n          return TreePosition.CONTAINS | TreePosition.PRECEDING; // other is ancestor of reference\n        }\n\n        leftAncestors.push(leftAncestor);\n        leftAncestor = this.parent(leftAncestor);\n      }\n    }\n    const rightAncestors = [];\n    {\n      let rightAncestor = right;\n\n      while (rightAncestor) {\n        if (rightAncestor === left) {\n          return TreePosition.CONTAINED_BY | TreePosition.FOLLOWING;\n        }\n\n        rightAncestors.push(rightAncestor);\n        rightAncestor = this.parent(rightAncestor);\n      }\n    }\n    const root = reverseArrayIndex(leftAncestors, 0);\n\n    if (!root || root !== reverseArrayIndex(rightAncestors, 0)) {\n      // note: unlike DOM, preceding / following is not set here\n      return TreePosition.DISCONNECTED;\n    } // find the lowest common ancestor\n\n\n    let commonAncestorIndex = 0;\n    const ancestorsMinLength = Math.min(leftAncestors.length, rightAncestors.length);\n\n    for (let i = 0; i < ancestorsMinLength; ++i) {\n      const leftAncestor = reverseArrayIndex(leftAncestors, i);\n      const rightAncestor = reverseArrayIndex(rightAncestors, i);\n\n      if (leftAncestor !== rightAncestor) {\n        break;\n      }\n\n      commonAncestorIndex = i;\n    } // indexes within the common ancestor\n\n\n    const leftIndex = this.index(reverseArrayIndex(leftAncestors, commonAncestorIndex + 1));\n    const rightIndex = this.index(reverseArrayIndex(rightAncestors, commonAncestorIndex + 1));\n    return rightIndex < leftIndex ? TreePosition.PRECEDING : TreePosition.FOLLOWING;\n  }\n  /**\r\n   * Remove the object from this tree.\r\n   * Has no effect if already removed.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method remove\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} removeObject\r\n   * @return {Object} removeObject\r\n   */\n\n\n  remove(removeObject) {\n    const removeNode = this._node(removeObject);\n\n    const parentNode = this._node(removeNode.parent);\n\n    const prevNode = this._node(removeNode.previousSibling);\n\n    const nextNode = this._node(removeNode.nextSibling);\n\n    if (parentNode) {\n      if (parentNode.firstChild === removeObject) {\n        parentNode.firstChild = removeNode.nextSibling;\n      }\n\n      if (parentNode.lastChild === removeObject) {\n        parentNode.lastChild = removeNode.previousSibling;\n      }\n    }\n\n    if (prevNode) {\n      prevNode.nextSibling = removeNode.nextSibling;\n    }\n\n    if (nextNode) {\n      nextNode.previousSibling = removeNode.previousSibling;\n    }\n\n    removeNode.parent = null;\n    removeNode.previousSibling = null;\n    removeNode.nextSibling = null;\n    removeNode.cachedIndex = -1;\n    removeNode.cachedIndexVersion = NaN;\n\n    if (parentNode) {\n      parentNode.childrenChanged();\n    }\n\n    return removeObject;\n  }\n  /**\r\n   * Insert the given object before the reference object.\r\n   * `newObject` is now the previous sibling of `referenceObject`.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method insertBefore\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} referenceObject\r\n   * @param {Object} newObject\r\n   * @throws {Error} If the newObject is already present in this SymbolTree\r\n   * @return {Object} newObject\r\n   */\n\n\n  insertBefore(referenceObject, newObject) {\n    const referenceNode = this._node(referenceObject);\n\n    const prevNode = this._node(referenceNode.previousSibling);\n\n    const newNode = this._node(newObject);\n\n    const parentNode = this._node(referenceNode.parent);\n\n    if (newNode.isAttached) {\n      throw Error('Given object is already present in this SymbolTree, remove it first');\n    }\n\n    newNode.parent = referenceNode.parent;\n    newNode.previousSibling = referenceNode.previousSibling;\n    newNode.nextSibling = referenceObject;\n    referenceNode.previousSibling = newObject;\n\n    if (prevNode) {\n      prevNode.nextSibling = newObject;\n    }\n\n    if (parentNode && parentNode.firstChild === referenceObject) {\n      parentNode.firstChild = newObject;\n    }\n\n    if (parentNode) {\n      parentNode.childrenChanged();\n    }\n\n    return newObject;\n  }\n  /**\r\n   * Insert the given object after the reference object.\r\n   * `newObject` is now the next sibling of `referenceObject`.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method insertAfter\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} referenceObject\r\n   * @param {Object} newObject\r\n   * @throws {Error} If the newObject is already present in this SymbolTree\r\n   * @return {Object} newObject\r\n   */\n\n\n  insertAfter(referenceObject, newObject) {\n    const referenceNode = this._node(referenceObject);\n\n    const nextNode = this._node(referenceNode.nextSibling);\n\n    const newNode = this._node(newObject);\n\n    const parentNode = this._node(referenceNode.parent);\n\n    if (newNode.isAttached) {\n      throw Error('Given object is already present in this SymbolTree, remove it first');\n    }\n\n    newNode.parent = referenceNode.parent;\n    newNode.previousSibling = referenceObject;\n    newNode.nextSibling = referenceNode.nextSibling;\n    referenceNode.nextSibling = newObject;\n\n    if (nextNode) {\n      nextNode.previousSibling = newObject;\n    }\n\n    if (parentNode && parentNode.lastChild === referenceObject) {\n      parentNode.lastChild = newObject;\n    }\n\n    if (parentNode) {\n      parentNode.childrenChanged();\n    }\n\n    return newObject;\n  }\n  /**\r\n   * Insert the given object as the first child of the given reference object.\r\n   * `newObject` is now the first child of `referenceObject`.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method prependChild\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} referenceObject\r\n   * @param {Object} newObject\r\n   * @throws {Error} If the newObject is already present in this SymbolTree\r\n   * @return {Object} newObject\r\n   */\n\n\n  prependChild(referenceObject, newObject) {\n    const referenceNode = this._node(referenceObject);\n\n    const newNode = this._node(newObject);\n\n    if (newNode.isAttached) {\n      throw Error('Given object is already present in this SymbolTree, remove it first');\n    }\n\n    if (referenceNode.hasChildren) {\n      this.insertBefore(referenceNode.firstChild, newObject);\n    } else {\n      newNode.parent = referenceObject;\n      referenceNode.firstChild = newObject;\n      referenceNode.lastChild = newObject;\n      referenceNode.childrenChanged();\n    }\n\n    return newObject;\n  }\n  /**\r\n   * Insert the given object as the last child of the given reference object.\r\n   * `newObject` is now the last child of `referenceObject`.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method appendChild\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} referenceObject\r\n   * @param {Object} newObject\r\n   * @throws {Error} If the newObject is already present in this SymbolTree\r\n   * @return {Object} newObject\r\n   */\n\n\n  appendChild(referenceObject, newObject) {\n    const referenceNode = this._node(referenceObject);\n\n    const newNode = this._node(newObject);\n\n    if (newNode.isAttached) {\n      throw Error('Given object is already present in this SymbolTree, remove it first');\n    }\n\n    if (referenceNode.hasChildren) {\n      this.insertAfter(referenceNode.lastChild, newObject);\n    } else {\n      newNode.parent = referenceObject;\n      referenceNode.firstChild = newObject;\n      referenceNode.lastChild = newObject;\n      referenceNode.childrenChanged();\n    }\n\n    return newObject;\n  }\n\n}\n\nmodule.exports = SymbolTree;\nSymbolTree.TreePosition = TreePosition;","map":{"version":3,"sources":["R:/Programs/CSEA Placements Website/kindergarten-website-template/placementWebsite/frontend/node_modules/symbol-tree/lib/SymbolTree.js"],"names":["SymbolTreeNode","require","TreePosition","TreeIterator","returnTrue","reverseArrayIndex","array","reverseIndex","length","SymbolTree","constructor","description","symbol","Symbol","initialize","object","_node","node","hasChildren","firstChild","lastChild","previousSibling","nextSibling","parent","lastInclusiveDescendant","current","preceding","options","treeRoot","root","following","skipChildren","childrenToArray","filter","thisArg","undefined","parentNode","index","setCachedIndex","call","push","ancestorsToArray","ancestor","treeToArray","childrenIterator","reverse","PREV","NEXT","previousSiblingsIterator","nextSiblingsIterator","ancestorsIterator","PARENT","treeIterator","PRECEDING","FOLLOWING","child","childNode","currentIndex","getCachedIndex","childIndexCachedUpTo","cachedUpToNode","childrenCount","compareTreePosition","left","right","leftAncestors","leftAncestor","CONTAINS","rightAncestors","rightAncestor","CONTAINED_BY","DISCONNECTED","commonAncestorIndex","ancestorsMinLength","Math","min","i","leftIndex","rightIndex","remove","removeObject","removeNode","prevNode","nextNode","cachedIndex","cachedIndexVersion","NaN","childrenChanged","insertBefore","referenceObject","newObject","referenceNode","newNode","isAttached","Error","insertAfter","prependChild","appendChild","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\n/**\r\n * @module symbol-tree\r\n * @author Joris van der Wel <joris@jorisvanderwel.com>\r\n */\r\n\r\nconst SymbolTreeNode = require('./SymbolTreeNode');\r\nconst TreePosition = require('./TreePosition');\r\nconst TreeIterator = require('./TreeIterator');\r\n\r\nfunction returnTrue() {\r\n        return true;\r\n}\r\n\r\nfunction reverseArrayIndex(array, reverseIndex) {\r\n        return array[array.length - 1 - reverseIndex]; // no need to check `index >= 0`\r\n}\r\n\r\nclass SymbolTree {\r\n\r\n        /**\r\n         * @constructor\r\n         * @alias module:symbol-tree\r\n         * @param {string} [description='SymbolTree data'] Description used for the Symbol\r\n         */\r\n        constructor(description) {\r\n                this.symbol = Symbol(description || 'SymbolTree data');\r\n        }\r\n\r\n        /**\r\n         * You can use this function to (optionally) initialize an object right after its creation,\r\n         * to take advantage of V8's fast properties. Also useful if you would like to\r\n         * freeze your object.\r\n         *\r\n         * `O(1)`\r\n         *\r\n         * @method\r\n         * @alias module:symbol-tree#initialize\r\n         * @param {Object} object\r\n         * @return {Object} object\r\n         */\r\n        initialize(object) {\r\n                this._node(object);\r\n\r\n                return object;\r\n        }\r\n\r\n        _node(object) {\r\n                if (!object) {\r\n                        return null;\r\n                }\r\n\r\n                const node = object[this.symbol];\r\n\r\n                if (node) {\r\n                        return node;\r\n                }\r\n\r\n                return (object[this.symbol] = new SymbolTreeNode());\r\n        }\r\n\r\n        /**\r\n         * Returns `true` if the object has any children. Otherwise it returns `false`.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method hasChildren\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Boolean}\r\n         */\r\n        hasChildren(object) {\r\n                return this._node(object).hasChildren;\r\n        }\r\n\r\n        /**\r\n         * Returns the first child of the given object.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method firstChild\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object}\r\n         */\r\n        firstChild(object) {\r\n                return this._node(object).firstChild;\r\n        }\r\n\r\n        /**\r\n         * Returns the last child of the given object.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method lastChild\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object}\r\n         */\r\n        lastChild(object) {\r\n                return this._node(object).lastChild;\r\n        }\r\n\r\n        /**\r\n         * Returns the previous sibling of the given object.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method previousSibling\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object}\r\n         */\r\n        previousSibling(object) {\r\n                return this._node(object).previousSibling;\r\n        }\r\n\r\n        /**\r\n         * Returns the next sibling of the given object.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method nextSibling\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object}\r\n         */\r\n        nextSibling(object) {\r\n                return this._node(object).nextSibling;\r\n        }\r\n\r\n        /**\r\n         * Return the parent of the given object.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method parent\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object}\r\n         */\r\n        parent(object) {\r\n                return this._node(object).parent;\r\n        }\r\n\r\n        /**\r\n         * Find the inclusive descendant that is last in tree order of the given object.\r\n         *\r\n         * * `O(n)` (worst case) where `n` is the depth of the subtree of `object`\r\n         *\r\n         * @method lastInclusiveDescendant\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object}\r\n         */\r\n        lastInclusiveDescendant(object) {\r\n                let lastChild;\r\n                let current = object;\r\n\r\n                while ((lastChild = this._node(current).lastChild)) {\r\n                        current = lastChild;\r\n                }\r\n\r\n                return current;\r\n        }\r\n\r\n        /**\r\n         * Find the preceding object (A) of the given object (B).\r\n         * An object A is preceding an object B if A and B are in the same tree\r\n         * and A comes before B in tree order.\r\n         *\r\n         * * `O(n)` (worst case)\r\n         * * `O(1)` (amortized when walking the entire tree)\r\n         *\r\n         * @method preceding\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @param {Object} [options]\r\n         * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\r\n         *        of the return value (or else null is returned). This check _assumes_\r\n         *        that `root` is also an inclusive ancestor of the given `object`\r\n         * @return {?Object}\r\n         */\r\n        preceding(object, options) {\r\n                const treeRoot = options && options.root;\r\n\r\n                if (object === treeRoot) {\r\n                        return null;\r\n                }\r\n\r\n                const previousSibling = this._node(object).previousSibling;\r\n\r\n                if (previousSibling) {\r\n                        return this.lastInclusiveDescendant(previousSibling);\r\n                }\r\n\r\n                // if there is no previous sibling return the parent (might be null)\r\n                return this._node(object).parent;\r\n        }\r\n\r\n        /**\r\n         * Find the following object (A) of the given object (B).\r\n         * An object A is following an object B if A and B are in the same tree\r\n         * and A comes after B in tree order.\r\n         *\r\n         * * `O(n)` (worst case) where `n` is the amount of objects in the entire tree\r\n         * * `O(1)` (amortized when walking the entire tree)\r\n         *\r\n         * @method following\r\n         * @memberOf module:symbol-tree#\r\n         * @param {!Object} object\r\n         * @param {Object} [options]\r\n         * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\r\n         *        of the return value (or else null is returned). This check _assumes_\r\n         *        that `root` is also an inclusive ancestor of the given `object`\r\n         * @param {Boolean} [options.skipChildren=false] If set, ignore the children of `object`\r\n         * @return {?Object}\r\n         */\r\n        following(object, options) {\r\n                const treeRoot = options && options.root;\r\n                const skipChildren = options && options.skipChildren;\r\n\r\n                const firstChild = !skipChildren && this._node(object).firstChild;\r\n\r\n                if (firstChild) {\r\n                        return firstChild;\r\n                }\r\n\r\n                let current = object;\r\n\r\n                do {\r\n                        if (current === treeRoot) {\r\n                                return null;\r\n                        }\r\n\r\n                        const nextSibling = this._node(current).nextSibling;\r\n\r\n                        if (nextSibling) {\r\n                                return nextSibling;\r\n                        }\r\n\r\n                        current = this._node(current).parent;\r\n                } while (current);\r\n\r\n                return null;\r\n        }\r\n\r\n        /**\r\n         * Append all children of the given object to an array.\r\n         *\r\n         * * `O(n)` where `n` is the amount of children of the given `parent`\r\n         *\r\n         * @method childrenToArray\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} parent\r\n         * @param {Object} [options]\r\n         * @param {Object[]} [options.array=[]]\r\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\r\n         *                            Invoked with arguments (object). Should return `true` if an object\r\n         *                            is to be included.\r\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\r\n         * @return {Object[]}\r\n         */\r\n        childrenToArray(parent, options) {\r\n                const array   = (options && options.array) || [];\r\n                const filter  = (options && options.filter) || returnTrue;\r\n                const thisArg = (options && options.thisArg) || undefined;\r\n\r\n                const parentNode = this._node(parent);\r\n                let object = parentNode.firstChild;\r\n                let index = 0;\r\n\r\n                while (object) {\r\n                        const node = this._node(object);\r\n                        node.setCachedIndex(parentNode, index);\r\n\r\n                        if (filter.call(thisArg, object)) {\r\n                                array.push(object);\r\n                        }\r\n\r\n                        object = node.nextSibling;\r\n                        ++index;\r\n                }\r\n\r\n                return array;\r\n        }\r\n\r\n        /**\r\n         * Append all inclusive ancestors of the given object to an array.\r\n         *\r\n         * * `O(n)` where `n` is the amount of ancestors of the given `object`\r\n         *\r\n         * @method ancestorsToArray\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @param {Object} [options]\r\n         * @param {Object[]} [options.array=[]]\r\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\r\n         *                            Invoked with arguments (object). Should return `true` if an object\r\n         *                            is to be included.\r\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\r\n         * @return {Object[]}\r\n         */\r\n        ancestorsToArray(object, options) {\r\n                const array   = (options && options.array) || [];\r\n                const filter  = (options && options.filter) || returnTrue;\r\n                const thisArg = (options && options.thisArg) || undefined;\r\n\r\n                let ancestor = object;\r\n\r\n                while (ancestor) {\r\n                        if (filter.call(thisArg, ancestor)) {\r\n                                array.push(ancestor);\r\n                        }\r\n                        ancestor = this._node(ancestor).parent;\r\n                }\r\n\r\n                return array;\r\n        }\r\n\r\n        /**\r\n         * Append all descendants of the given object to an array (in tree order).\r\n         *\r\n         * * `O(n)` where `n` is the amount of objects in the sub-tree of the given `object`\r\n         *\r\n         * @method treeToArray\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} root\r\n         * @param {Object} [options]\r\n         * @param {Object[]} [options.array=[]]\r\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\r\n         *                            Invoked with arguments (object). Should return `true` if an object\r\n         *                            is to be included.\r\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\r\n         * @return {Object[]}\r\n         */\r\n        treeToArray(root, options) {\r\n                const array   = (options && options.array) || [];\r\n                const filter  = (options && options.filter) || returnTrue;\r\n                const thisArg = (options && options.thisArg) || undefined;\r\n\r\n                let object = root;\r\n\r\n                while (object) {\r\n                        if (filter.call(thisArg, object)) {\r\n                                array.push(object);\r\n                        }\r\n                        object = this.following(object, {root: root});\r\n                }\r\n\r\n                return array;\r\n        }\r\n\r\n        /**\r\n         * Iterate over all children of the given object\r\n         *\r\n         * * `O(1)` for a single iteration\r\n         *\r\n         * @method childrenIterator\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} parent\r\n         * @param {Object} [options]\r\n         * @param {Boolean} [options.reverse=false]\r\n         * @return {Object} An iterable iterator (ES6)\r\n         */\r\n        childrenIterator(parent, options) {\r\n                const reverse = options && options.reverse;\r\n                const parentNode = this._node(parent);\r\n\r\n                return new TreeIterator(\r\n                        this,\r\n                        parent,\r\n                        reverse ? parentNode.lastChild : parentNode.firstChild,\r\n                        reverse ? TreeIterator.PREV : TreeIterator.NEXT\r\n                );\r\n        }\r\n\r\n        /**\r\n         * Iterate over all the previous siblings of the given object. (in reverse tree order)\r\n         *\r\n         * * `O(1)` for a single iteration\r\n         *\r\n         * @method previousSiblingsIterator\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object} An iterable iterator (ES6)\r\n         */\r\n        previousSiblingsIterator(object) {\r\n                return new TreeIterator(\r\n                        this,\r\n                        object,\r\n                        this._node(object).previousSibling,\r\n                        TreeIterator.PREV\r\n                );\r\n        }\r\n\r\n        /**\r\n         * Iterate over all the next siblings of the given object. (in tree order)\r\n         *\r\n         * * `O(1)` for a single iteration\r\n         *\r\n         * @method nextSiblingsIterator\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object} An iterable iterator (ES6)\r\n         */\r\n        nextSiblingsIterator(object) {\r\n                return new TreeIterator(\r\n                        this,\r\n                        object,\r\n                        this._node(object).nextSibling,\r\n                        TreeIterator.NEXT\r\n                );\r\n        }\r\n\r\n        /**\r\n         * Iterate over all inclusive ancestors of the given object\r\n         *\r\n         * * `O(1)` for a single iteration\r\n         *\r\n         * @method ancestorsIterator\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object} An iterable iterator (ES6)\r\n         */\r\n        ancestorsIterator(object) {\r\n                return new TreeIterator(\r\n                        this,\r\n                        object,\r\n                        object,\r\n                        TreeIterator.PARENT\r\n                );\r\n        }\r\n\r\n        /**\r\n         * Iterate over all descendants of the given object (in tree order).\r\n         *\r\n         * Where `n` is the amount of objects in the sub-tree of the given `root`:\r\n         *\r\n         * * `O(n)` (worst case for a single iteration)\r\n         * * `O(n)` (amortized, when completing the iterator)\r\n         *\r\n         * @method treeIterator\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} root\r\n         * @param {Object} options\r\n         * @param {Boolean} [options.reverse=false]\r\n         * @return {Object} An iterable iterator (ES6)\r\n         */\r\n        treeIterator(root, options) {\r\n                const reverse = options && options.reverse;\r\n\r\n                return new TreeIterator(\r\n                        this,\r\n                        root,\r\n                        reverse ? this.lastInclusiveDescendant(root) : root,\r\n                        reverse ? TreeIterator.PRECEDING : TreeIterator.FOLLOWING\r\n                );\r\n        }\r\n\r\n        /**\r\n         * Find the index of the given object (the number of preceding siblings).\r\n         *\r\n         * * `O(n)` where `n` is the amount of preceding siblings\r\n         * * `O(1)` (amortized, if the tree is not modified)\r\n         *\r\n         * @method index\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} child\r\n         * @return {Number} The number of preceding siblings, or -1 if the object has no parent\r\n         */\r\n        index(child) {\r\n                const childNode = this._node(child);\r\n                const parentNode = this._node(childNode.parent);\r\n\r\n                if (!parentNode) {\r\n                        // In principal, you could also find out the number of preceding siblings\r\n                        // for objects that do not have a parent. This method limits itself only to\r\n                        // objects that have a parent because that lets us optimize more.\r\n                        return -1;\r\n                }\r\n\r\n                let currentIndex = childNode.getCachedIndex(parentNode);\r\n\r\n                if (currentIndex >= 0) {\r\n                        return currentIndex;\r\n                }\r\n\r\n                currentIndex = 0;\r\n                let object = parentNode.firstChild;\r\n\r\n                if (parentNode.childIndexCachedUpTo) {\r\n                        const cachedUpToNode = this._node(parentNode.childIndexCachedUpTo);\r\n                        object = cachedUpToNode.nextSibling;\r\n                        currentIndex = cachedUpToNode.getCachedIndex(parentNode) + 1;\r\n                }\r\n\r\n                while (object) {\r\n                        const node = this._node(object);\r\n                        node.setCachedIndex(parentNode, currentIndex);\r\n\r\n                        if (object === child) {\r\n                                break;\r\n                        }\r\n\r\n                        ++currentIndex;\r\n                        object = node.nextSibling;\r\n                }\r\n\r\n                parentNode.childIndexCachedUpTo = child;\r\n\r\n                return currentIndex;\r\n        }\r\n\r\n        /**\r\n         * Calculate the number of children.\r\n         *\r\n         * * `O(n)` where `n` is the amount of children\r\n         * * `O(1)` (amortized, if the tree is not modified)\r\n         *\r\n         * @method childrenCount\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} parent\r\n         * @return {Number}\r\n         */\r\n        childrenCount(parent) {\r\n                const parentNode = this._node(parent);\r\n\r\n                if (!parentNode.lastChild) {\r\n                        return 0;\r\n                }\r\n\r\n                return this.index(parentNode.lastChild) + 1;\r\n        }\r\n\r\n        /**\r\n         * Compare the position of an object relative to another object. A bit set is returned:\r\n         *\r\n         * <ul>\r\n         *     <li>DISCONNECTED : 1</li>\r\n         *     <li>PRECEDING : 2</li>\r\n         *     <li>FOLLOWING : 4</li>\r\n         *     <li>CONTAINS : 8</li>\r\n         *     <li>CONTAINED_BY : 16</li>\r\n         * </ul>\r\n         *\r\n         * The semantics are the same as compareDocumentPosition in DOM, with the exception that\r\n         * DISCONNECTED never occurs with any other bit.\r\n         *\r\n         * where `n` and `m` are the amount of ancestors of `left` and `right`;\r\n         * where `o` is the amount of children of the lowest common ancestor of `left` and `right`:\r\n         *\r\n         * * `O(n + m + o)` (worst case)\r\n         * * `O(n + m)` (amortized, if the tree is not modified)\r\n         *\r\n         * @method compareTreePosition\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} left\r\n         * @param {Object} right\r\n         * @return {Number}\r\n         */\r\n        compareTreePosition(left, right) {\r\n                // In DOM terms:\r\n                // left = reference / context object\r\n                // right = other\r\n\r\n                if (left === right) {\r\n                        return 0;\r\n                }\r\n\r\n                /* jshint -W016 */\r\n\r\n                const leftAncestors = []; { // inclusive\r\n                        let leftAncestor = left;\r\n\r\n                        while (leftAncestor) {\r\n                                if (leftAncestor === right) {\r\n                                        return TreePosition.CONTAINS | TreePosition.PRECEDING;\r\n                                        // other is ancestor of reference\r\n                                }\r\n\r\n                                leftAncestors.push(leftAncestor);\r\n                                leftAncestor = this.parent(leftAncestor);\r\n                        }\r\n                }\r\n\r\n\r\n                const rightAncestors = []; {\r\n                        let rightAncestor = right;\r\n\r\n                        while (rightAncestor) {\r\n                                if (rightAncestor === left) {\r\n                                        return TreePosition.CONTAINED_BY | TreePosition.FOLLOWING;\r\n                                }\r\n\r\n                                rightAncestors.push(rightAncestor);\r\n                                rightAncestor = this.parent(rightAncestor);\r\n                        }\r\n                }\r\n\r\n\r\n                const root = reverseArrayIndex(leftAncestors, 0);\r\n\r\n                if (!root || root !== reverseArrayIndex(rightAncestors, 0)) {\r\n                        // note: unlike DOM, preceding / following is not set here\r\n                        return TreePosition.DISCONNECTED;\r\n                }\r\n\r\n                // find the lowest common ancestor\r\n                let commonAncestorIndex = 0;\r\n                const ancestorsMinLength = Math.min(leftAncestors.length, rightAncestors.length);\r\n\r\n                for (let i = 0; i < ancestorsMinLength; ++i) {\r\n                        const leftAncestor  = reverseArrayIndex(leftAncestors, i);\r\n                        const rightAncestor = reverseArrayIndex(rightAncestors, i);\r\n\r\n                        if (leftAncestor !== rightAncestor) {\r\n                                break;\r\n                        }\r\n\r\n                        commonAncestorIndex = i;\r\n                }\r\n\r\n                // indexes within the common ancestor\r\n                const leftIndex  = this.index(reverseArrayIndex(leftAncestors, commonAncestorIndex + 1));\r\n                const rightIndex = this.index(reverseArrayIndex(rightAncestors, commonAncestorIndex + 1));\r\n\r\n                return rightIndex < leftIndex\r\n                        ? TreePosition.PRECEDING\r\n                        : TreePosition.FOLLOWING;\r\n        }\r\n\r\n        /**\r\n         * Remove the object from this tree.\r\n         * Has no effect if already removed.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method remove\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} removeObject\r\n         * @return {Object} removeObject\r\n         */\r\n        remove(removeObject) {\r\n                const removeNode = this._node(removeObject);\r\n                const parentNode = this._node(removeNode.parent);\r\n                const prevNode = this._node(removeNode.previousSibling);\r\n                const nextNode = this._node(removeNode.nextSibling);\r\n\r\n                if (parentNode) {\r\n                        if (parentNode.firstChild === removeObject) {\r\n                                parentNode.firstChild = removeNode.nextSibling;\r\n                        }\r\n\r\n                        if (parentNode.lastChild === removeObject) {\r\n                                parentNode.lastChild = removeNode.previousSibling;\r\n                        }\r\n                }\r\n\r\n                if (prevNode) {\r\n                        prevNode.nextSibling = removeNode.nextSibling;\r\n                }\r\n\r\n                if (nextNode) {\r\n                        nextNode.previousSibling = removeNode.previousSibling;\r\n                }\r\n\r\n                removeNode.parent = null;\r\n                removeNode.previousSibling = null;\r\n                removeNode.nextSibling = null;\r\n                removeNode.cachedIndex = -1;\r\n                removeNode.cachedIndexVersion = NaN;\r\n\r\n                if (parentNode) {\r\n                        parentNode.childrenChanged();\r\n                }\r\n\r\n                return removeObject;\r\n        }\r\n\r\n        /**\r\n         * Insert the given object before the reference object.\r\n         * `newObject` is now the previous sibling of `referenceObject`.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method insertBefore\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} referenceObject\r\n         * @param {Object} newObject\r\n         * @throws {Error} If the newObject is already present in this SymbolTree\r\n         * @return {Object} newObject\r\n         */\r\n        insertBefore(referenceObject, newObject) {\r\n                const referenceNode = this._node(referenceObject);\r\n                const prevNode = this._node(referenceNode.previousSibling);\r\n                const newNode = this._node(newObject);\r\n                const parentNode = this._node(referenceNode.parent);\r\n\r\n                if (newNode.isAttached) {\r\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\r\n                }\r\n\r\n                newNode.parent = referenceNode.parent;\r\n                newNode.previousSibling = referenceNode.previousSibling;\r\n                newNode.nextSibling = referenceObject;\r\n                referenceNode.previousSibling = newObject;\r\n\r\n                if (prevNode) {\r\n                        prevNode.nextSibling = newObject;\r\n                }\r\n\r\n                if (parentNode && parentNode.firstChild === referenceObject) {\r\n                        parentNode.firstChild = newObject;\r\n                }\r\n\r\n                if (parentNode) {\r\n                        parentNode.childrenChanged();\r\n                }\r\n\r\n                return newObject;\r\n        }\r\n\r\n        /**\r\n         * Insert the given object after the reference object.\r\n         * `newObject` is now the next sibling of `referenceObject`.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method insertAfter\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} referenceObject\r\n         * @param {Object} newObject\r\n         * @throws {Error} If the newObject is already present in this SymbolTree\r\n         * @return {Object} newObject\r\n         */\r\n        insertAfter(referenceObject, newObject) {\r\n                const referenceNode = this._node(referenceObject);\r\n                const nextNode = this._node(referenceNode.nextSibling);\r\n                const newNode = this._node(newObject);\r\n                const parentNode = this._node(referenceNode.parent);\r\n\r\n                if (newNode.isAttached) {\r\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\r\n                }\r\n\r\n                newNode.parent = referenceNode.parent;\r\n                newNode.previousSibling = referenceObject;\r\n                newNode.nextSibling = referenceNode.nextSibling;\r\n                referenceNode.nextSibling = newObject;\r\n\r\n                if (nextNode) {\r\n                        nextNode.previousSibling = newObject;\r\n                }\r\n\r\n                if (parentNode && parentNode.lastChild === referenceObject) {\r\n                        parentNode.lastChild = newObject;\r\n                }\r\n\r\n                if (parentNode) {\r\n                        parentNode.childrenChanged();\r\n                }\r\n\r\n                return newObject;\r\n        }\r\n\r\n        /**\r\n         * Insert the given object as the first child of the given reference object.\r\n         * `newObject` is now the first child of `referenceObject`.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method prependChild\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} referenceObject\r\n         * @param {Object} newObject\r\n         * @throws {Error} If the newObject is already present in this SymbolTree\r\n         * @return {Object} newObject\r\n         */\r\n        prependChild(referenceObject, newObject) {\r\n                const referenceNode = this._node(referenceObject);\r\n                const newNode = this._node(newObject);\r\n\r\n                if (newNode.isAttached) {\r\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\r\n                }\r\n\r\n                if (referenceNode.hasChildren) {\r\n                        this.insertBefore(referenceNode.firstChild, newObject);\r\n                }\r\n                else {\r\n                        newNode.parent = referenceObject;\r\n                        referenceNode.firstChild = newObject;\r\n                        referenceNode.lastChild = newObject;\r\n                        referenceNode.childrenChanged();\r\n                }\r\n\r\n                return newObject;\r\n        }\r\n\r\n        /**\r\n         * Insert the given object as the last child of the given reference object.\r\n         * `newObject` is now the last child of `referenceObject`.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method appendChild\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} referenceObject\r\n         * @param {Object} newObject\r\n         * @throws {Error} If the newObject is already present in this SymbolTree\r\n         * @return {Object} newObject\r\n         */\r\n        appendChild(referenceObject, newObject) {\r\n                const referenceNode = this._node(referenceObject);\r\n                const newNode = this._node(newObject);\r\n\r\n                if (newNode.isAttached) {\r\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\r\n                }\r\n\r\n                if (referenceNode.hasChildren) {\r\n                        this.insertAfter(referenceNode.lastChild, newObject);\r\n                }\r\n                else {\r\n                        newNode.parent = referenceObject;\r\n                        referenceNode.firstChild = newObject;\r\n                        referenceNode.lastChild = newObject;\r\n                        referenceNode.childrenChanged();\r\n                }\r\n\r\n                return newObject;\r\n        }\r\n}\r\n\r\nmodule.exports = SymbolTree;\r\nSymbolTree.TreePosition = TreePosition;\r\n"]},"metadata":{},"sourceType":"script"}