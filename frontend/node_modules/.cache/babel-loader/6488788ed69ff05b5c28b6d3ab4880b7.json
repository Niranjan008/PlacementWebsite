{"ast":null,"code":"\"use strict\";\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst {\n  clone\n} = require(\"../node\");\n\nconst NODE_TYPE = require(\"../node-type\");\n\nconst {\n  parseFragment\n} = require(\"../../browser/parser/index\");\n\nconst {\n  HTML_NS\n} = require(\"../helpers/namespaces\");\n\nconst {\n  domSymbolTree\n} = require(\"../helpers/internal-constants\");\n\nconst {\n  compareBoundaryPointsPosition\n} = require(\"./boundary-point\");\n\nconst {\n  nodeRoot,\n  nodeLength,\n  isInclusiveAncestor\n} = require(\"../helpers/node\");\n\nconst {\n  createElement\n} = require(\"../helpers/create-element\");\n\nconst AbstractRangeImpl = require(\"./AbstractRange-impl\").implementation;\n\nconst Range = require(\"../generated/Range\");\n\nconst DocumentFragment = require(\"../generated/DocumentFragment\");\n\nconst {\n  implForWrapper\n} = require(\"../generated/utils\");\n\nconst RANGE_COMPARISON_TYPE = {\n  START_TO_START: 0,\n  START_TO_END: 1,\n  END_TO_END: 2,\n  END_TO_START: 3\n};\n\nclass RangeImpl extends AbstractRangeImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n    const defaultBoundaryPoint = {\n      node: implForWrapper(globalObject._document),\n      offset: 0\n    };\n    const {\n      start = defaultBoundaryPoint,\n      end = defaultBoundaryPoint\n    } = privateData;\n\n    this._setLiveRangeStart(start.node, start.offset);\n\n    this._setLiveRangeEnd(end.node, end.offset);\n  } // https://dom.spec.whatwg.org/#dom-range-commonancestorcontainer\n\n\n  get commonAncestorContainer() {\n    const {\n      _start,\n      _end\n    } = this;\n\n    for (const container of domSymbolTree.ancestorsIterator(_start.node)) {\n      if (isInclusiveAncestor(container, _end.node)) {\n        return container;\n      }\n    }\n\n    return null;\n  } // https://dom.spec.whatwg.org/#dom-range-setstart\n\n\n  setStart(node, offset) {\n    setBoundaryPointStart(this, node, offset);\n  } // https://dom.spec.whatwg.org/#dom-range-setend\n\n\n  setEnd(node, offset) {\n    setBoundaryPointEnd(this, node, offset);\n  } // https://dom.spec.whatwg.org/#dom-range-setstartbefore\n\n\n  setStartBefore(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointStart(this, parent, domSymbolTree.index(node));\n  } // https://dom.spec.whatwg.org/#dom-range-setstartafter\n\n\n  setStartAfter(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointStart(this, parent, domSymbolTree.index(node) + 1);\n  } // https://dom.spec.whatwg.org/#dom-range-setendbefore\n\n\n  setEndBefore(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointEnd(this, parent, domSymbolTree.index(node));\n  } // https://dom.spec.whatwg.org/#dom-range-setendafter\n\n\n  setEndAfter(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointEnd(this, parent, domSymbolTree.index(node) + 1);\n  } // https://dom.spec.whatwg.org/#dom-range-collapse\n\n\n  collapse(toStart) {\n    if (toStart) {\n      this._setLiveRangeEnd(this._start.node, this._start.offset);\n    } else {\n      this._setLiveRangeStart(this._end.node, this._end.offset);\n    }\n  } // https://dom.spec.whatwg.org/#dom-range-selectnode\n\n\n  selectNode(node) {\n    selectNodeWithinRange(node, this);\n  } // https://dom.spec.whatwg.org/#dom-range-selectnodecontents\n\n\n  selectNodeContents(node) {\n    if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n      throw DOMException.create(this._globalObject, [\"DocumentType Node can't be used as boundary point.\", \"InvalidNodeTypeError\"]);\n    }\n\n    const length = nodeLength(node);\n\n    this._setLiveRangeStart(node, 0);\n\n    this._setLiveRangeEnd(node, length);\n  } // https://dom.spec.whatwg.org/#dom-range-compareboundarypoints\n\n\n  compareBoundaryPoints(how, sourceRange) {\n    if (how !== RANGE_COMPARISON_TYPE.START_TO_START && how !== RANGE_COMPARISON_TYPE.START_TO_END && how !== RANGE_COMPARISON_TYPE.END_TO_END && how !== RANGE_COMPARISON_TYPE.END_TO_START) {\n      const message = \"The comparison method provided must be one of 'START_TO_START', 'START_TO_END', 'END_TO_END', \" + \"or 'END_TO_START'.\";\n      throw DOMException.create(this._globalObject, [message, \"NotSupportedError\"]);\n    }\n\n    if (this._root !== sourceRange._root) {\n      throw DOMException.create(this._globalObject, [\"The two Ranges are not in the same tree.\", \"WrongDocumentError\"]);\n    }\n\n    let thisPoint;\n    let otherPoint;\n\n    if (how === RANGE_COMPARISON_TYPE.START_TO_START) {\n      thisPoint = this._start;\n      otherPoint = sourceRange._start;\n    } else if (how === RANGE_COMPARISON_TYPE.START_TO_END) {\n      thisPoint = this._end;\n      otherPoint = sourceRange._start;\n    } else if (how === RANGE_COMPARISON_TYPE.END_TO_END) {\n      thisPoint = this._end;\n      otherPoint = sourceRange._end;\n    } else {\n      thisPoint = this._start;\n      otherPoint = sourceRange._end;\n    }\n\n    return compareBoundaryPointsPosition(thisPoint, otherPoint);\n  } // https://dom.spec.whatwg.org/#dom-range-deletecontents\n\n\n  deleteContents() {\n    if (this.collapsed) {\n      return;\n    }\n\n    const {\n      _start: originalStart,\n      _end: originalEnd\n    } = this;\n\n    if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n      originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n      return;\n    }\n\n    const nodesToRemove = [];\n    let currentNode = this._start.node;\n    const endNode = nextNodeDescendant(this._end.node);\n\n    while (currentNode && currentNode !== endNode) {\n      if (isContained(currentNode, this) && !isContained(domSymbolTree.parent(currentNode), this)) {\n        nodesToRemove.push(currentNode);\n      }\n\n      currentNode = domSymbolTree.following(currentNode);\n    }\n\n    let newNode;\n    let newOffset;\n\n    if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n      newNode = originalStart.node;\n      newOffset = originalStart.offset;\n    } else {\n      let referenceNode = originalStart.node;\n\n      while (referenceNode && !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)) {\n        referenceNode = domSymbolTree.parent(referenceNode);\n      }\n\n      newNode = domSymbolTree.parent(referenceNode);\n      newOffset = domSymbolTree.index(referenceNode) + 1;\n    }\n\n    if (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE) {\n      originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n    }\n\n    for (const node of nodesToRemove) {\n      const parent = domSymbolTree.parent(node);\n      parent.removeChild(node);\n    }\n\n    if (originalEnd.node.nodeType === NODE_TYPE.TEXT_NODE || originalEnd.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalEnd.node.nodeType === NODE_TYPE.COMMENT_NODE) {\n      originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n    }\n\n    this._setLiveRangeStart(newNode, newOffset);\n\n    this._setLiveRangeEnd(newNode, newOffset);\n  } // https://dom.spec.whatwg.org/#dom-range-extractcontents\n\n\n  extractContents() {\n    return extractRange(this);\n  } // https://dom.spec.whatwg.org/#dom-range-clonecontents\n\n\n  cloneContents() {\n    return cloneRange(this);\n  } // https://dom.spec.whatwg.org/#dom-range-insertnode\n\n\n  insertNode(node) {\n    insertNodeInRange(node, this);\n  } // https://dom.spec.whatwg.org/#dom-range-surroundcontents\n\n\n  surroundContents(newParent) {\n    let node = this.commonAncestorContainer;\n    const endNode = nextNodeDescendant(node);\n\n    while (node !== endNode) {\n      if (node.nodeType !== NODE_TYPE.TEXT_NODE && isPartiallyContained(node, this)) {\n        throw DOMException.create(this._globalObject, [\"The Range has partially contains a non-Text node.\", \"InvalidStateError\"]);\n      }\n\n      node = domSymbolTree.following(node);\n    }\n\n    if (newParent.nodeType === NODE_TYPE.DOCUMENT_NODE || newParent.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || newParent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      throw DOMException.create(this._globalObject, [\"Invalid element type.\", \"InvalidNodeTypeError\"]);\n    }\n\n    const fragment = extractRange(this);\n\n    while (domSymbolTree.firstChild(newParent)) {\n      newParent.removeChild(domSymbolTree.firstChild(newParent));\n    }\n\n    insertNodeInRange(newParent, this);\n    newParent.appendChild(fragment);\n    selectNodeWithinRange(newParent, this);\n  } // https://dom.spec.whatwg.org/#dom-range-clonerange\n\n\n  cloneRange() {\n    const {\n      _start,\n      _end,\n      _globalObject\n    } = this;\n    return Range.createImpl(_globalObject, [], {\n      start: {\n        node: _start.node,\n        offset: _start.offset\n      },\n      end: {\n        node: _end.node,\n        offset: _end.offset\n      }\n    });\n  } // https://dom.spec.whatwg.org/#dom-range-detach\n\n\n  detach() {// Do nothing by spec!\n  } // https://dom.spec.whatwg.org/#dom-range-ispointinrange\n\n\n  isPointInRange(node, offset) {\n    if (nodeRoot(node) !== this._root) {\n      return false;\n    }\n\n    validateSetBoundaryPoint(node, offset);\n    const bp = {\n      node,\n      offset\n    };\n\n    if (compareBoundaryPointsPosition(bp, this._start) === -1 || compareBoundaryPointsPosition(bp, this._end) === 1) {\n      return false;\n    }\n\n    return true;\n  } // https://dom.spec.whatwg.org/#dom-range-comparepoint\n\n\n  comparePoint(node, offset) {\n    if (nodeRoot(node) !== this._root) {\n      throw DOMException.create(this._globalObject, [\"The given Node and the Range are not in the same tree.\", \"WrongDocumentError\"]);\n    }\n\n    validateSetBoundaryPoint(node, offset);\n    const bp = {\n      node,\n      offset\n    };\n\n    if (compareBoundaryPointsPosition(bp, this._start) === -1) {\n      return -1;\n    } else if (compareBoundaryPointsPosition(bp, this._end) === 1) {\n      return 1;\n    }\n\n    return 0;\n  } // https://dom.spec.whatwg.org/#dom-range-intersectsnode\n\n\n  intersectsNode(node) {\n    if (nodeRoot(node) !== this._root) {\n      return false;\n    }\n\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      return true;\n    }\n\n    const offset = domSymbolTree.index(node);\n    return compareBoundaryPointsPosition({\n      node: parent,\n      offset\n    }, this._end) === -1 && compareBoundaryPointsPosition({\n      node: parent,\n      offset: offset + 1\n    }, this._start) === 1;\n  } // https://dom.spec.whatwg.org/#dom-range-stringifier\n\n\n  toString() {\n    let s = \"\";\n    const {\n      _start,\n      _end\n    } = this;\n\n    if (_start.node === _end.node && _start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      return _start.node.data.slice(_start.offset, _end.offset);\n    }\n\n    if (_start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      s += _start.node.data.slice(_start.offset);\n    }\n\n    let currentNode = _start.node;\n    const endNode = nextNodeDescendant(_end.node);\n\n    while (currentNode && currentNode !== endNode) {\n      if (currentNode.nodeType === NODE_TYPE.TEXT_NODE && isContained(currentNode, this)) {\n        s += currentNode.data;\n      }\n\n      currentNode = domSymbolTree.following(currentNode);\n    }\n\n    if (_end.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      s += _end.node.data.slice(0, _end.offset);\n    }\n\n    return s;\n  } // https://w3c.github.io/DOM-Parsing/#dom-range-createcontextualfragment\n\n\n  createContextualFragment(fragment) {\n    const {\n      node\n    } = this._start;\n    let element;\n\n    switch (node.nodeType) {\n      case NODE_TYPE.DOCUMENT_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        element = null;\n        break;\n\n      case NODE_TYPE.ELEMENT_NODE:\n        element = node;\n        break;\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        element = node.parentElement;\n        break;\n\n      default:\n        throw new Error(\"Internal error: Invalid range start node\");\n    }\n\n    if (element === null || element._ownerDocument._parsingMode === \"html\" && element._localName === \"html\" && element._namespaceURI === HTML_NS) {\n      element = createElement(node._ownerDocument, \"body\", HTML_NS);\n    }\n\n    return parseFragment(fragment, element);\n  } // https://dom.spec.whatwg.org/#concept-range-root\n\n\n  get _root() {\n    return nodeRoot(this._start.node);\n  }\n\n  _setLiveRangeStart(node, offset) {\n    if (this._start && this._start.node !== node) {\n      this._start.node._referencedRanges.delete(this);\n    }\n\n    if (!node._referencedRanges.has(this)) {\n      node._referencedRanges.add(this);\n    }\n\n    this._start = {\n      node,\n      offset\n    };\n  }\n\n  _setLiveRangeEnd(node, offset) {\n    if (this._end && this._end.node !== node) {\n      this._end.node._referencedRanges.delete(this);\n    }\n\n    if (!node._referencedRanges.has(this)) {\n      node._referencedRanges.add(this);\n    }\n\n    this._end = {\n      node,\n      offset\n    };\n  }\n\n}\n\nfunction nextNodeDescendant(node) {\n  while (node && !domSymbolTree.nextSibling(node)) {\n    node = domSymbolTree.parent(node);\n  }\n\n  if (!node) {\n    return null;\n  }\n\n  return domSymbolTree.nextSibling(node);\n} // https://dom.spec.whatwg.org/#concept-range-bp-set\n\n\nfunction validateSetBoundaryPoint(node, offset) {\n  if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n    throw DOMException.create(node._globalObject, [\"DocumentType Node can't be used as boundary point.\", \"InvalidNodeTypeError\"]);\n  }\n\n  if (offset > nodeLength(node)) {\n    throw DOMException.create(node._globalObject, [\"Offset out of bound.\", \"IndexSizeError\"]);\n  }\n}\n\nfunction setBoundaryPointStart(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n  const bp = {\n    node,\n    offset\n  };\n\n  if (nodeRoot(node) !== range._root || compareBoundaryPointsPosition(bp, range._end) === 1) {\n    range._setLiveRangeEnd(node, offset);\n  }\n\n  range._setLiveRangeStart(node, offset);\n}\n\nfunction setBoundaryPointEnd(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n  const bp = {\n    node,\n    offset\n  };\n\n  if (nodeRoot(node) !== range._root || compareBoundaryPointsPosition(bp, range._start) === -1) {\n    range._setLiveRangeStart(node, offset);\n  }\n\n  range._setLiveRangeEnd(node, offset);\n} // https://dom.spec.whatwg.org/#concept-range-select\n\n\nfunction selectNodeWithinRange(node, range) {\n  const parent = domSymbolTree.parent(node);\n\n  if (!parent) {\n    throw DOMException.create(node._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n  }\n\n  const index = domSymbolTree.index(node);\n\n  range._setLiveRangeStart(parent, index);\n\n  range._setLiveRangeEnd(parent, index + 1);\n} // https://dom.spec.whatwg.org/#contained\n\n\nfunction isContained(node, range) {\n  const {\n    _start,\n    _end\n  } = range;\n  return compareBoundaryPointsPosition({\n    node,\n    offset: 0\n  }, _start) === 1 && compareBoundaryPointsPosition({\n    node,\n    offset: nodeLength(node)\n  }, _end) === -1;\n} // https://dom.spec.whatwg.org/#partially-contained\n\n\nfunction isPartiallyContained(node, range) {\n  const {\n    _start,\n    _end\n  } = range;\n  return isInclusiveAncestor(node, _start.node) && !isInclusiveAncestor(node, _end.node) || !isInclusiveAncestor(node, _start.node) && isInclusiveAncestor(node, _end.node);\n} // https://dom.spec.whatwg.org/#concept-range-insert\n\n\nfunction insertNodeInRange(node, range) {\n  const {\n    node: startNode,\n    offset: startOffset\n  } = range._start;\n\n  if (startNode.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || startNode.nodeType === NODE_TYPE.COMMENT_NODE || startNode.nodeType === NODE_TYPE.TEXT_NODE && !domSymbolTree.parent(startNode) || node === startNode) {\n    throw DOMException.create(node._globalObject, [\"Invalid start node.\", \"HierarchyRequestError\"]);\n  }\n\n  let referenceNode = startNode.nodeType === NODE_TYPE.TEXT_NODE ? startNode : domSymbolTree.childrenToArray(startNode)[startOffset] || null;\n  const parent = !referenceNode ? startNode : domSymbolTree.parent(referenceNode);\n\n  parent._preInsertValidity(node, referenceNode);\n\n  if (startNode.nodeType === NODE_TYPE.TEXT_NODE) {\n    referenceNode = startNode.splitText(startOffset);\n  }\n\n  if (node === referenceNode) {\n    referenceNode = domSymbolTree.nextSibling(referenceNode);\n  }\n\n  const nodeParent = domSymbolTree.parent(node);\n\n  if (nodeParent) {\n    nodeParent.removeChild(node);\n  }\n\n  let newOffset = !referenceNode ? nodeLength(parent) : domSymbolTree.index(referenceNode);\n  newOffset += node.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? nodeLength(node) : 1;\n  parent.insertBefore(node, referenceNode);\n\n  if (range.collapsed) {\n    range._setLiveRangeEnd(parent, newOffset);\n  }\n} // https://dom.spec.whatwg.org/#concept-range-clone\n\n\nfunction cloneRange(range) {\n  const {\n    _start: originalStart,\n    _end: originalEnd,\n    _globalObject\n  } = range;\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n\n  if (range.collapsed) {\n    return fragment;\n  }\n\n  if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n    fragment.appendChild(cloned);\n    return fragment;\n  }\n\n  let commonAncestor = originalStart.node;\n\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n\n  let firstPartialContainedChild = null;\n\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    let candidate = domSymbolTree.firstChild(commonAncestor);\n\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n\n  let lastPartiallyContainedChild = null;\n\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    let candidate = domSymbolTree.lastChild(commonAncestor);\n\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        lastPartiallyContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.previousSibling(candidate);\n    }\n  }\n\n  const containedChildren = domSymbolTree.childrenToArray(commonAncestor).filter(node => isContained(node, range));\n  const hasDoctypeChildren = containedChildren.some(node => node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);\n\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n\n  if (firstPartialContainedChild !== null && (firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n    fragment.appendChild(cloned);\n  } else if (firstPartialContainedChild !== null) {\n    const cloned = clone(firstPartialContainedChild);\n    fragment.appendChild(cloned);\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: originalStart.node,\n        offset: originalStart.offset\n      },\n      end: {\n        node: firstPartialContainedChild,\n        offset: nodeLength(firstPartialContainedChild)\n      }\n    });\n    const subfragment = cloneRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  for (const containedChild of containedChildren) {\n    const cloned = clone(containedChild, undefined, true);\n    fragment.appendChild(cloned);\n  }\n\n  if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalEnd.node);\n    cloned._data = cloned.substringData(0, originalEnd.offset);\n    fragment.appendChild(cloned);\n  } else if (lastPartiallyContainedChild !== null) {\n    const cloned = clone(lastPartiallyContainedChild);\n    fragment.appendChild(cloned);\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: lastPartiallyContainedChild,\n        offset: 0\n      },\n      end: {\n        node: originalEnd.node,\n        offset: originalEnd.offset\n      }\n    });\n    const subfragment = cloneRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  return fragment;\n} // https://dom.spec.whatwg.org/#concept-range-extract\n\n\nfunction extractRange(range) {\n  const {\n    _start: originalStart,\n    _end: originalEnd,\n    _globalObject\n  } = range;\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n\n  if (range.collapsed) {\n    return fragment;\n  }\n\n  if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n    fragment.appendChild(cloned);\n    originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n    return fragment;\n  }\n\n  let commonAncestor = originalStart.node;\n\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n\n  let firstPartialContainedChild = null;\n\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    let candidate = domSymbolTree.firstChild(commonAncestor);\n\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n\n  let lastPartiallyContainedChild = null;\n\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    let candidate = domSymbolTree.lastChild(commonAncestor);\n\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        lastPartiallyContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.previousSibling(candidate);\n    }\n  }\n\n  const containedChildren = domSymbolTree.childrenToArray(commonAncestor).filter(node => isContained(node, range));\n  const hasDoctypeChildren = containedChildren.some(node => node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);\n\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n\n  let newNode;\n  let newOffset;\n\n  if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    newNode = originalStart.node;\n    newOffset = originalStart.offset;\n  } else {\n    let referenceNode = originalStart.node;\n\n    while (referenceNode && !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)) {\n      referenceNode = domSymbolTree.parent(referenceNode);\n    }\n\n    newNode = domSymbolTree.parent(referenceNode);\n    newOffset = domSymbolTree.index(referenceNode) + 1;\n  }\n\n  if (firstPartialContainedChild !== null && (firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n    fragment.appendChild(cloned);\n    originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n  } else if (firstPartialContainedChild !== null) {\n    const cloned = clone(firstPartialContainedChild);\n    fragment.appendChild(cloned);\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: originalStart.node,\n        offset: originalStart.offset\n      },\n      end: {\n        node: firstPartialContainedChild,\n        offset: nodeLength(firstPartialContainedChild)\n      }\n    });\n    const subfragment = extractRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  for (const containedChild of containedChildren) {\n    fragment.appendChild(containedChild);\n  }\n\n  if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalEnd.node);\n    cloned._data = cloned.substringData(0, originalEnd.offset);\n    fragment.appendChild(cloned);\n    originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n  } else if (lastPartiallyContainedChild !== null) {\n    const cloned = clone(lastPartiallyContainedChild);\n    fragment.appendChild(cloned);\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: lastPartiallyContainedChild,\n        offset: 0\n      },\n      end: {\n        node: originalEnd.node,\n        offset: originalEnd.offset\n      }\n    });\n    const subfragment = extractRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  range._setLiveRangeStart(newNode, newOffset);\n\n  range._setLiveRangeEnd(newNode, newOffset);\n\n  return fragment;\n}\n\nmodule.exports = {\n  implementation: RangeImpl,\n  setBoundaryPointStart,\n  setBoundaryPointEnd\n};","map":{"version":3,"sources":["R:/Programs/CSEA Placements Website/kindergarten-website-template/placementWebsite/frontend/node_modules/jsdom/lib/jsdom/living/range/Range-impl.js"],"names":["DOMException","require","clone","NODE_TYPE","parseFragment","HTML_NS","domSymbolTree","compareBoundaryPointsPosition","nodeRoot","nodeLength","isInclusiveAncestor","createElement","AbstractRangeImpl","implementation","Range","DocumentFragment","implForWrapper","RANGE_COMPARISON_TYPE","START_TO_START","START_TO_END","END_TO_END","END_TO_START","RangeImpl","constructor","globalObject","args","privateData","defaultBoundaryPoint","node","_document","offset","start","end","_setLiveRangeStart","_setLiveRangeEnd","commonAncestorContainer","_start","_end","container","ancestorsIterator","setStart","setBoundaryPointStart","setEnd","setBoundaryPointEnd","setStartBefore","parent","create","_globalObject","index","setStartAfter","setEndBefore","setEndAfter","collapse","toStart","selectNode","selectNodeWithinRange","selectNodeContents","nodeType","DOCUMENT_TYPE_NODE","length","compareBoundaryPoints","how","sourceRange","message","_root","thisPoint","otherPoint","deleteContents","collapsed","originalStart","originalEnd","TEXT_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","replaceData","nodesToRemove","currentNode","endNode","nextNodeDescendant","isContained","push","following","newNode","newOffset","referenceNode","removeChild","extractContents","extractRange","cloneContents","cloneRange","insertNode","insertNodeInRange","surroundContents","newParent","isPartiallyContained","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","fragment","firstChild","appendChild","createImpl","detach","isPointInRange","validateSetBoundaryPoint","bp","comparePoint","intersectsNode","toString","s","data","slice","createContextualFragment","element","ELEMENT_NODE","parentElement","Error","_ownerDocument","_parsingMode","_localName","_namespaceURI","_referencedRanges","delete","has","add","nextSibling","range","startNode","startOffset","childrenToArray","_preInsertValidity","splitText","nodeParent","insertBefore","ownerDocument","cloned","_data","substringData","commonAncestor","firstPartialContainedChild","candidate","lastPartiallyContainedChild","lastChild","previousSibling","containedChildren","filter","hasDoctypeChildren","some","subrange","subfragment","containedChild","undefined","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\r\n\r\nconst { clone } = require(\"../node\");\r\nconst NODE_TYPE = require(\"../node-type\");\r\nconst { parseFragment } = require(\"../../browser/parser/index\");\r\n\r\nconst { HTML_NS } = require(\"../helpers/namespaces\");\r\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\r\nconst { compareBoundaryPointsPosition } = require(\"./boundary-point\");\r\nconst { nodeRoot, nodeLength, isInclusiveAncestor } = require(\"../helpers/node\");\r\nconst { createElement } = require(\"../helpers/create-element\");\r\n\r\nconst AbstractRangeImpl = require(\"./AbstractRange-impl\").implementation;\r\n\r\nconst Range = require(\"../generated/Range\");\r\nconst DocumentFragment = require(\"../generated/DocumentFragment\");\r\nconst { implForWrapper } = require(\"../generated/utils\");\r\n\r\nconst RANGE_COMPARISON_TYPE = {\r\n  START_TO_START: 0,\r\n  START_TO_END: 1,\r\n  END_TO_END: 2,\r\n  END_TO_START: 3\r\n};\r\n\r\nclass RangeImpl extends AbstractRangeImpl {\r\n  constructor(globalObject, args, privateData) {\r\n    super(globalObject, args, privateData);\r\n\r\n    const defaultBoundaryPoint = {\r\n      node: implForWrapper(globalObject._document),\r\n      offset: 0\r\n    };\r\n\r\n    const {\r\n      start = defaultBoundaryPoint,\r\n      end = defaultBoundaryPoint\r\n    } = privateData;\r\n\r\n    this._setLiveRangeStart(start.node, start.offset);\r\n    this._setLiveRangeEnd(end.node, end.offset);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-commonancestorcontainer\r\n  get commonAncestorContainer() {\r\n    const { _start, _end } = this;\r\n\r\n    for (const container of domSymbolTree.ancestorsIterator(_start.node)) {\r\n      if (isInclusiveAncestor(container, _end.node)) {\r\n        return container;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-setstart\r\n  setStart(node, offset) {\r\n    setBoundaryPointStart(this, node, offset);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-setend\r\n  setEnd(node, offset) {\r\n    setBoundaryPointEnd(this, node, offset);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-setstartbefore\r\n  setStartBefore(node) {\r\n    const parent = domSymbolTree.parent(node);\r\n\r\n    if (!parent) {\r\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\r\n    }\r\n\r\n    setBoundaryPointStart(this, parent, domSymbolTree.index(node));\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-setstartafter\r\n  setStartAfter(node) {\r\n    const parent = domSymbolTree.parent(node);\r\n\r\n    if (!parent) {\r\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\r\n    }\r\n\r\n    setBoundaryPointStart(this, parent, domSymbolTree.index(node) + 1);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-setendbefore\r\n  setEndBefore(node) {\r\n    const parent = domSymbolTree.parent(node);\r\n\r\n    if (!parent) {\r\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\r\n    }\r\n\r\n    setBoundaryPointEnd(this, parent, domSymbolTree.index(node));\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-setendafter\r\n  setEndAfter(node) {\r\n    const parent = domSymbolTree.parent(node);\r\n\r\n    if (!parent) {\r\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\r\n    }\r\n\r\n    setBoundaryPointEnd(this, parent, domSymbolTree.index(node) + 1);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-collapse\r\n  collapse(toStart) {\r\n    if (toStart) {\r\n      this._setLiveRangeEnd(this._start.node, this._start.offset);\r\n    } else {\r\n      this._setLiveRangeStart(this._end.node, this._end.offset);\r\n    }\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-selectnode\r\n  selectNode(node) {\r\n    selectNodeWithinRange(node, this);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-selectnodecontents\r\n  selectNodeContents(node) {\r\n    if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\r\n      throw DOMException.create(this._globalObject, [\r\n        \"DocumentType Node can't be used as boundary point.\",\r\n        \"InvalidNodeTypeError\"\r\n      ]);\r\n    }\r\n\r\n    const length = nodeLength(node);\r\n\r\n    this._setLiveRangeStart(node, 0);\r\n    this._setLiveRangeEnd(node, length);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-compareboundarypoints\r\n  compareBoundaryPoints(how, sourceRange) {\r\n    if (\r\n      how !== RANGE_COMPARISON_TYPE.START_TO_START &&\r\n      how !== RANGE_COMPARISON_TYPE.START_TO_END &&\r\n      how !== RANGE_COMPARISON_TYPE.END_TO_END &&\r\n      how !== RANGE_COMPARISON_TYPE.END_TO_START\r\n    ) {\r\n      const message = \"The comparison method provided must be one of 'START_TO_START', 'START_TO_END', 'END_TO_END', \" +\r\n                      \"or 'END_TO_START'.\";\r\n      throw DOMException.create(this._globalObject, [message, \"NotSupportedError\"]);\r\n    }\r\n\r\n    if (this._root !== sourceRange._root) {\r\n      throw DOMException.create(this._globalObject, [\"The two Ranges are not in the same tree.\", \"WrongDocumentError\"]);\r\n    }\r\n\r\n    let thisPoint;\r\n    let otherPoint;\r\n    if (how === RANGE_COMPARISON_TYPE.START_TO_START) {\r\n      thisPoint = this._start;\r\n      otherPoint = sourceRange._start;\r\n    } else if (how === RANGE_COMPARISON_TYPE.START_TO_END) {\r\n      thisPoint = this._end;\r\n      otherPoint = sourceRange._start;\r\n    } else if (how === RANGE_COMPARISON_TYPE.END_TO_END) {\r\n      thisPoint = this._end;\r\n      otherPoint = sourceRange._end;\r\n    } else {\r\n      thisPoint = this._start;\r\n      otherPoint = sourceRange._end;\r\n    }\r\n\r\n    return compareBoundaryPointsPosition(thisPoint, otherPoint);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-deletecontents\r\n  deleteContents() {\r\n    if (this.collapsed) {\r\n      return;\r\n    }\r\n\r\n    const { _start: originalStart, _end: originalEnd } = this;\r\n\r\n    if (\r\n      originalStart.node === originalEnd.node &&\r\n      (\r\n        originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\r\n        originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n        originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\r\n      )\r\n    ) {\r\n      originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\r\n      return;\r\n    }\r\n\r\n    const nodesToRemove = [];\r\n    let currentNode = this._start.node;\r\n    const endNode = nextNodeDescendant(this._end.node);\r\n    while (currentNode && currentNode !== endNode) {\r\n      if (\r\n        isContained(currentNode, this) &&\r\n        !isContained(domSymbolTree.parent(currentNode), this)\r\n      ) {\r\n        nodesToRemove.push(currentNode);\r\n      }\r\n\r\n      currentNode = domSymbolTree.following(currentNode);\r\n    }\r\n\r\n    let newNode;\r\n    let newOffset;\r\n    if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\r\n      newNode = originalStart.node;\r\n      newOffset = originalStart.offset;\r\n    } else {\r\n      let referenceNode = originalStart.node;\r\n\r\n      while (\r\n        referenceNode &&\r\n        !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)\r\n      ) {\r\n        referenceNode = domSymbolTree.parent(referenceNode);\r\n      }\r\n\r\n      newNode = domSymbolTree.parent(referenceNode);\r\n      newOffset = domSymbolTree.index(referenceNode) + 1;\r\n    }\r\n\r\n    if (\r\n      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\r\n      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\r\n    ) {\r\n      originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\r\n    }\r\n\r\n    for (const node of nodesToRemove) {\r\n      const parent = domSymbolTree.parent(node);\r\n      parent.removeChild(node);\r\n    }\r\n\r\n    if (\r\n      originalEnd.node.nodeType === NODE_TYPE.TEXT_NODE ||\r\n      originalEnd.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n      originalEnd.node.nodeType === NODE_TYPE.COMMENT_NODE\r\n    ) {\r\n      originalEnd.node.replaceData(0, originalEnd.offset, \"\");\r\n    }\r\n\r\n    this._setLiveRangeStart(newNode, newOffset);\r\n    this._setLiveRangeEnd(newNode, newOffset);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-extractcontents\r\n  extractContents() {\r\n    return extractRange(this);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-clonecontents\r\n  cloneContents() {\r\n    return cloneRange(this);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-insertnode\r\n  insertNode(node) {\r\n    insertNodeInRange(node, this);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-surroundcontents\r\n  surroundContents(newParent) {\r\n    let node = this.commonAncestorContainer;\r\n    const endNode = nextNodeDescendant(node);\r\n    while (node !== endNode) {\r\n      if (node.nodeType !== NODE_TYPE.TEXT_NODE && isPartiallyContained(node, this)) {\r\n        throw DOMException.create(this._globalObject, [\r\n          \"The Range has partially contains a non-Text node.\",\r\n          \"InvalidStateError\"\r\n        ]);\r\n      }\r\n\r\n      node = domSymbolTree.following(node);\r\n    }\r\n\r\n    if (\r\n      newParent.nodeType === NODE_TYPE.DOCUMENT_NODE ||\r\n      newParent.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE ||\r\n      newParent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE\r\n    ) {\r\n      throw DOMException.create(this._globalObject, [\"Invalid element type.\", \"InvalidNodeTypeError\"]);\r\n    }\r\n\r\n    const fragment = extractRange(this);\r\n\r\n    while (domSymbolTree.firstChild(newParent)) {\r\n      newParent.removeChild(domSymbolTree.firstChild(newParent));\r\n    }\r\n\r\n    insertNodeInRange(newParent, this);\r\n\r\n    newParent.appendChild(fragment);\r\n\r\n    selectNodeWithinRange(newParent, this);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-clonerange\r\n  cloneRange() {\r\n    const { _start, _end, _globalObject } = this;\r\n\r\n    return Range.createImpl(_globalObject, [], {\r\n      start: { node: _start.node, offset: _start.offset },\r\n      end: { node: _end.node, offset: _end.offset }\r\n    });\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-detach\r\n  detach() {\r\n    // Do nothing by spec!\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-ispointinrange\r\n  isPointInRange(node, offset) {\r\n    if (nodeRoot(node) !== this._root) {\r\n      return false;\r\n    }\r\n\r\n    validateSetBoundaryPoint(node, offset);\r\n\r\n    const bp = { node, offset };\r\n\r\n    if (\r\n      compareBoundaryPointsPosition(bp, this._start) === -1 ||\r\n      compareBoundaryPointsPosition(bp, this._end) === 1\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-comparepoint\r\n  comparePoint(node, offset) {\r\n    if (nodeRoot(node) !== this._root) {\r\n      throw DOMException.create(this._globalObject, [\r\n        \"The given Node and the Range are not in the same tree.\",\r\n        \"WrongDocumentError\"\r\n      ]);\r\n    }\r\n\r\n    validateSetBoundaryPoint(node, offset);\r\n\r\n    const bp = { node, offset };\r\n    if (compareBoundaryPointsPosition(bp, this._start) === -1) {\r\n      return -1;\r\n    } else if (compareBoundaryPointsPosition(bp, this._end) === 1) {\r\n      return 1;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-intersectsnode\r\n  intersectsNode(node) {\r\n    if (nodeRoot(node) !== this._root) {\r\n      return false;\r\n    }\r\n\r\n    const parent = domSymbolTree.parent(node);\r\n    if (!parent) {\r\n      return true;\r\n    }\r\n\r\n    const offset = domSymbolTree.index(node);\r\n\r\n    return (\r\n      compareBoundaryPointsPosition({ node: parent, offset }, this._end) === -1 &&\r\n      compareBoundaryPointsPosition({ node: parent, offset: offset + 1 }, this._start) === 1\r\n    );\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-stringifier\r\n  toString() {\r\n    let s = \"\";\r\n    const { _start, _end } = this;\r\n\r\n    if (_start.node === _end.node && _start.node.nodeType === NODE_TYPE.TEXT_NODE) {\r\n      return _start.node.data.slice(_start.offset, _end.offset);\r\n    }\r\n\r\n    if (_start.node.nodeType === NODE_TYPE.TEXT_NODE) {\r\n      s += _start.node.data.slice(_start.offset);\r\n    }\r\n\r\n    let currentNode = _start.node;\r\n    const endNode = nextNodeDescendant(_end.node);\r\n    while (currentNode && currentNode !== endNode) {\r\n      if (currentNode.nodeType === NODE_TYPE.TEXT_NODE && isContained(currentNode, this)) {\r\n        s += currentNode.data;\r\n      }\r\n\r\n      currentNode = domSymbolTree.following(currentNode);\r\n    }\r\n\r\n    if (_end.node.nodeType === NODE_TYPE.TEXT_NODE) {\r\n      s += _end.node.data.slice(0, _end.offset);\r\n    }\r\n\r\n    return s;\r\n  }\r\n\r\n  // https://w3c.github.io/DOM-Parsing/#dom-range-createcontextualfragment\r\n  createContextualFragment(fragment) {\r\n    const { node } = this._start;\r\n\r\n    let element;\r\n    switch (node.nodeType) {\r\n      case NODE_TYPE.DOCUMENT_NODE:\r\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\r\n        element = null;\r\n        break;\r\n\r\n      case NODE_TYPE.ELEMENT_NODE:\r\n        element = node;\r\n        break;\r\n\r\n      case NODE_TYPE.TEXT_NODE:\r\n      case NODE_TYPE.COMMENT_NODE:\r\n        element = node.parentElement;\r\n        break;\r\n\r\n      default:\r\n        throw new Error(\"Internal error: Invalid range start node\");\r\n    }\r\n\r\n    if (\r\n      element === null || (\r\n        element._ownerDocument._parsingMode === \"html\" &&\r\n        element._localName === \"html\" &&\r\n        element._namespaceURI === HTML_NS\r\n      )\r\n    ) {\r\n      element = createElement(node._ownerDocument, \"body\", HTML_NS);\r\n    }\r\n\r\n    return parseFragment(fragment, element);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#concept-range-root\r\n  get _root() {\r\n    return nodeRoot(this._start.node);\r\n  }\r\n\r\n  _setLiveRangeStart(node, offset) {\r\n    if (this._start && this._start.node !== node) {\r\n      this._start.node._referencedRanges.delete(this);\r\n    }\r\n\r\n    if (!node._referencedRanges.has(this)) {\r\n      node._referencedRanges.add(this);\r\n    }\r\n\r\n    this._start = {\r\n      node,\r\n      offset\r\n    };\r\n  }\r\n\r\n  _setLiveRangeEnd(node, offset) {\r\n    if (this._end && this._end.node !== node) {\r\n      this._end.node._referencedRanges.delete(this);\r\n    }\r\n\r\n    if (!node._referencedRanges.has(this)) {\r\n      node._referencedRanges.add(this);\r\n    }\r\n\r\n    this._end = {\r\n      node,\r\n      offset\r\n    };\r\n  }\r\n}\r\n\r\n\r\nfunction nextNodeDescendant(node) {\r\n  while (node && !domSymbolTree.nextSibling(node)) {\r\n    node = domSymbolTree.parent(node);\r\n  }\r\n\r\n  if (!node) {\r\n    return null;\r\n  }\r\n\r\n  return domSymbolTree.nextSibling(node);\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#concept-range-bp-set\r\nfunction validateSetBoundaryPoint(node, offset) {\r\n  if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\r\n    throw DOMException.create(node._globalObject, [\r\n      \"DocumentType Node can't be used as boundary point.\",\r\n      \"InvalidNodeTypeError\"\r\n    ]);\r\n  }\r\n\r\n  if (offset > nodeLength(node)) {\r\n    throw DOMException.create(node._globalObject, [\"Offset out of bound.\", \"IndexSizeError\"]);\r\n  }\r\n}\r\nfunction setBoundaryPointStart(range, node, offset) {\r\n  validateSetBoundaryPoint(node, offset);\r\n\r\n  const bp = { node, offset };\r\n  if (\r\n    nodeRoot(node) !== range._root ||\r\n    compareBoundaryPointsPosition(bp, range._end) === 1\r\n  ) {\r\n    range._setLiveRangeEnd(node, offset);\r\n  }\r\n\r\n  range._setLiveRangeStart(node, offset);\r\n}\r\nfunction setBoundaryPointEnd(range, node, offset) {\r\n  validateSetBoundaryPoint(node, offset);\r\n\r\n  const bp = { node, offset };\r\n  if (\r\n    nodeRoot(node) !== range._root ||\r\n    compareBoundaryPointsPosition(bp, range._start) === -1\r\n  ) {\r\n    range._setLiveRangeStart(node, offset);\r\n  }\r\n\r\n  range._setLiveRangeEnd(node, offset);\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#concept-range-select\r\nfunction selectNodeWithinRange(node, range) {\r\n  const parent = domSymbolTree.parent(node);\r\n\r\n  if (!parent) {\r\n    throw DOMException.create(node._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\r\n  }\r\n\r\n  const index = domSymbolTree.index(node);\r\n\r\n  range._setLiveRangeStart(parent, index);\r\n  range._setLiveRangeEnd(parent, index + 1);\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#contained\r\nfunction isContained(node, range) {\r\n  const { _start, _end } = range;\r\n  return (\r\n    compareBoundaryPointsPosition({ node, offset: 0 }, _start) === 1 &&\r\n    compareBoundaryPointsPosition({ node, offset: nodeLength(node) }, _end) === -1\r\n  );\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#partially-contained\r\nfunction isPartiallyContained(node, range) {\r\n  const { _start, _end } = range;\r\n  return (\r\n    (isInclusiveAncestor(node, _start.node) && !isInclusiveAncestor(node, _end.node)) ||\r\n    (!isInclusiveAncestor(node, _start.node) && isInclusiveAncestor(node, _end.node))\r\n  );\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#concept-range-insert\r\nfunction insertNodeInRange(node, range) {\r\n  const { node: startNode, offset: startOffset } = range._start;\r\n\r\n  if (\r\n    startNode.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n    startNode.nodeType === NODE_TYPE.COMMENT_NODE ||\r\n    (startNode.nodeType === NODE_TYPE.TEXT_NODE && !domSymbolTree.parent(startNode)) ||\r\n    node === startNode\r\n  ) {\r\n    throw DOMException.create(node._globalObject, [\"Invalid start node.\", \"HierarchyRequestError\"]);\r\n  }\r\n\r\n  let referenceNode = startNode.nodeType === NODE_TYPE.TEXT_NODE ?\r\n    startNode :\r\n    domSymbolTree.childrenToArray(startNode)[startOffset] || null;\r\n  const parent = !referenceNode ?\r\n    startNode :\r\n    domSymbolTree.parent(referenceNode);\r\n\r\n  parent._preInsertValidity(node, referenceNode);\r\n\r\n  if (startNode.nodeType === NODE_TYPE.TEXT_NODE) {\r\n    referenceNode = startNode.splitText(startOffset);\r\n  }\r\n\r\n  if (node === referenceNode) {\r\n    referenceNode = domSymbolTree.nextSibling(referenceNode);\r\n  }\r\n\r\n  const nodeParent = domSymbolTree.parent(node);\r\n  if (nodeParent) {\r\n    nodeParent.removeChild(node);\r\n  }\r\n\r\n  let newOffset = !referenceNode ? nodeLength(parent) : domSymbolTree.index(referenceNode);\r\n  newOffset += node.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? nodeLength(node) : 1;\r\n\r\n  parent.insertBefore(node, referenceNode);\r\n\r\n  if (range.collapsed) {\r\n    range._setLiveRangeEnd(parent, newOffset);\r\n  }\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#concept-range-clone\r\nfunction cloneRange(range) {\r\n  const { _start: originalStart, _end: originalEnd, _globalObject } = range;\r\n\r\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\r\n    ownerDocument: originalStart.node._ownerDocument\r\n  });\r\n\r\n  if (range.collapsed) {\r\n    return fragment;\r\n  }\r\n\r\n  if (\r\n    originalStart.node === originalEnd.node &&\r\n    (\r\n      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\r\n      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\r\n    )\r\n  ) {\r\n    const cloned = clone(originalStart.node);\r\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\r\n\r\n    fragment.appendChild(cloned);\r\n\r\n    return fragment;\r\n  }\r\n\r\n  let commonAncestor = originalStart.node;\r\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\r\n    commonAncestor = domSymbolTree.parent(commonAncestor);\r\n  }\r\n\r\n  let firstPartialContainedChild = null;\r\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\r\n    let candidate = domSymbolTree.firstChild(commonAncestor);\r\n    while (!firstPartialContainedChild) {\r\n      if (isPartiallyContained(candidate, range)) {\r\n        firstPartialContainedChild = candidate;\r\n      }\r\n\r\n      candidate = domSymbolTree.nextSibling(candidate);\r\n    }\r\n  }\r\n\r\n  let lastPartiallyContainedChild = null;\r\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\r\n    let candidate = domSymbolTree.lastChild(commonAncestor);\r\n    while (!lastPartiallyContainedChild) {\r\n      if (isPartiallyContained(candidate, range)) {\r\n        lastPartiallyContainedChild = candidate;\r\n      }\r\n\r\n      candidate = domSymbolTree.previousSibling(candidate);\r\n    }\r\n  }\r\n\r\n  const containedChildren = domSymbolTree.childrenToArray(commonAncestor)\r\n    .filter(node => isContained(node, range));\r\n\r\n  const hasDoctypeChildren = containedChildren.some(node => node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);\r\n  if (hasDoctypeChildren) {\r\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\r\n  }\r\n\r\n  if (\r\n    firstPartialContainedChild !== null &&\r\n    (\r\n      firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\r\n      firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n      firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\r\n    )\r\n  ) {\r\n    const cloned = clone(originalStart.node);\r\n    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\r\n\r\n    fragment.appendChild(cloned);\r\n  } else if (firstPartialContainedChild !== null) {\r\n    const cloned = clone(firstPartialContainedChild);\r\n    fragment.appendChild(cloned);\r\n\r\n    const subrange = Range.createImpl(_globalObject, [], {\r\n      start: { node: originalStart.node, offset: originalStart.offset },\r\n      end: { node: firstPartialContainedChild, offset: nodeLength(firstPartialContainedChild) }\r\n    });\r\n\r\n    const subfragment = cloneRange(subrange);\r\n    cloned.appendChild(subfragment);\r\n  }\r\n\r\n  for (const containedChild of containedChildren) {\r\n    const cloned = clone(containedChild, undefined, true);\r\n    fragment.appendChild(cloned);\r\n  }\r\n\r\n  if (\r\n    lastPartiallyContainedChild !== null &&\r\n    (\r\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\r\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\r\n    )\r\n  ) {\r\n    const cloned = clone(originalEnd.node);\r\n    cloned._data = cloned.substringData(0, originalEnd.offset);\r\n\r\n    fragment.appendChild(cloned);\r\n  } else if (lastPartiallyContainedChild !== null) {\r\n    const cloned = clone(lastPartiallyContainedChild);\r\n    fragment.appendChild(cloned);\r\n\r\n    const subrange = Range.createImpl(_globalObject, [], {\r\n      start: { node: lastPartiallyContainedChild, offset: 0 },\r\n      end: { node: originalEnd.node, offset: originalEnd.offset }\r\n    });\r\n\r\n    const subfragment = cloneRange(subrange);\r\n    cloned.appendChild(subfragment);\r\n  }\r\n\r\n  return fragment;\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#concept-range-extract\r\nfunction extractRange(range) {\r\n  const { _start: originalStart, _end: originalEnd, _globalObject } = range;\r\n\r\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\r\n    ownerDocument: originalStart.node._ownerDocument\r\n  });\r\n\r\n  if (range.collapsed) {\r\n    return fragment;\r\n  }\r\n\r\n  if (\r\n    originalStart.node === originalEnd.node &&\r\n    (\r\n      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\r\n      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\r\n    )\r\n  ) {\r\n    const cloned = clone(originalStart.node);\r\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\r\n\r\n    fragment.appendChild(cloned);\r\n    originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\r\n\r\n    return fragment;\r\n  }\r\n\r\n  let commonAncestor = originalStart.node;\r\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\r\n    commonAncestor = domSymbolTree.parent(commonAncestor);\r\n  }\r\n\r\n  let firstPartialContainedChild = null;\r\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\r\n    let candidate = domSymbolTree.firstChild(commonAncestor);\r\n    while (!firstPartialContainedChild) {\r\n      if (isPartiallyContained(candidate, range)) {\r\n        firstPartialContainedChild = candidate;\r\n      }\r\n\r\n      candidate = domSymbolTree.nextSibling(candidate);\r\n    }\r\n  }\r\n\r\n  let lastPartiallyContainedChild = null;\r\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\r\n    let candidate = domSymbolTree.lastChild(commonAncestor);\r\n    while (!lastPartiallyContainedChild) {\r\n      if (isPartiallyContained(candidate, range)) {\r\n        lastPartiallyContainedChild = candidate;\r\n      }\r\n\r\n      candidate = domSymbolTree.previousSibling(candidate);\r\n    }\r\n  }\r\n\r\n  const containedChildren = domSymbolTree.childrenToArray(commonAncestor)\r\n    .filter(node => isContained(node, range));\r\n\r\n  const hasDoctypeChildren = containedChildren.some(node => node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);\r\n  if (hasDoctypeChildren) {\r\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\r\n  }\r\n\r\n  let newNode;\r\n  let newOffset;\r\n  if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\r\n    newNode = originalStart.node;\r\n    newOffset = originalStart.offset;\r\n  } else {\r\n    let referenceNode = originalStart.node;\r\n\r\n    while (\r\n      referenceNode &&\r\n      !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)\r\n    ) {\r\n      referenceNode = domSymbolTree.parent(referenceNode);\r\n    }\r\n\r\n    newNode = domSymbolTree.parent(referenceNode);\r\n    newOffset = domSymbolTree.index(referenceNode) + 1;\r\n  }\r\n\r\n  if (\r\n    firstPartialContainedChild !== null &&\r\n    (\r\n      firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\r\n      firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n      firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\r\n    )\r\n  ) {\r\n    const cloned = clone(originalStart.node);\r\n    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\r\n\r\n    fragment.appendChild(cloned);\r\n\r\n    originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\r\n  } else if (firstPartialContainedChild !== null) {\r\n    const cloned = clone(firstPartialContainedChild);\r\n    fragment.appendChild(cloned);\r\n\r\n    const subrange = Range.createImpl(_globalObject, [], {\r\n      start: { node: originalStart.node, offset: originalStart.offset },\r\n      end: { node: firstPartialContainedChild, offset: nodeLength(firstPartialContainedChild) }\r\n    });\r\n\r\n    const subfragment = extractRange(subrange);\r\n    cloned.appendChild(subfragment);\r\n  }\r\n\r\n  for (const containedChild of containedChildren) {\r\n    fragment.appendChild(containedChild);\r\n  }\r\n\r\n  if (\r\n    lastPartiallyContainedChild !== null &&\r\n    (\r\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\r\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\r\n    )\r\n  ) {\r\n    const cloned = clone(originalEnd.node);\r\n    cloned._data = cloned.substringData(0, originalEnd.offset);\r\n\r\n    fragment.appendChild(cloned);\r\n\r\n    originalEnd.node.replaceData(0, originalEnd.offset, \"\");\r\n  } else if (lastPartiallyContainedChild !== null) {\r\n    const cloned = clone(lastPartiallyContainedChild);\r\n    fragment.appendChild(cloned);\r\n\r\n    const subrange = Range.createImpl(_globalObject, [], {\r\n      start: { node: lastPartiallyContainedChild, offset: 0 },\r\n      end: { node: originalEnd.node, offset: originalEnd.offset }\r\n    });\r\n\r\n    const subfragment = extractRange(subrange);\r\n    cloned.appendChild(subfragment);\r\n  }\r\n\r\n  range._setLiveRangeStart(newNode, newOffset);\r\n  range._setLiveRangeEnd(newNode, newOffset);\r\n\r\n  return fragment;\r\n}\r\n\r\nmodule.exports = {\r\n  implementation: RangeImpl,\r\n\r\n  setBoundaryPointStart,\r\n  setBoundaryPointEnd\r\n};\r\n"]},"metadata":{},"sourceType":"script"}